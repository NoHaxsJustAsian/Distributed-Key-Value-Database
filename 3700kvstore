#!/usr/bin/env python3

import argparse
import socket
import time
import json
import select
import struct
import sys
import math
import os
import random

BROADCAST = "FFFF"
replica_ids = ['0000', '0001', '0002', '0003', '0004']

class Replica:
    def __init__(self, port, id, others):
        # -- Starter Code --
        self.port = port
        self.id = id
        self.others = others
        # -- State --
        self.term = 0
        self.log = [{'src': '', 'key': '', 'value': '', 'MID': '', 'term': 0}]
        self.election_timeout = random.randint(150, 300) / 1000
        self.ongoing_election = False
        self.votedFor = ''
        self.votes = 0
        self.role = 'follower'
        self.leader = BROADCAST
        self.last_heartbeat = time.time()
        self.database = {}
        

        self.last = time.time()

        self.SELECT_WAIT_TIME = 0.01  # 10 milliseconds
        self.buffer = b''



        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def run(self):
        while True:
            rlist, _, _ = select.select([self.socket], [], [], 0.1)
            for s in rlist:
                data, addr = s.recvfrom(65535)
                full_message = data.decode('utf-8')
                print("Received message '%s'" % (full_message), flush=True)
                msg = json.loads(full_message)

                if msg['type'] == 'get':
                    self.handle_get(msg)

                elif msg['type'] == 'put':
                    self.handle_put(msg)

                elif msg['type'] == 'RequestVote RPC':
                    self.handle_request_vote(msg)

                elif msg['type'] == 'VoteTrue':
                    self.handle_vote(msg)

                elif msg['type'] == 'VoteFalse':
                    self.handle_rejected_vote(msg)

                elif msg['type'] == 'AppendEntries RPC':
                    last = time.time()
                    self.handle_append_entries(msg)


            """  if request["type"] in ["get", "put"]:
                    self.respond_to_client(request)
                elif request["type"] == "hello":
                    self.respond_to_raft_election(request)
                elif request["type"] == "election_announcement":
                    self.process_election_announcement(request)
                elif request["type"] == "vote_request":
                    self.process_vote_request(request)
                elif request["type"] == "vote":
                    self.process_vote(request)
                elif request["type"] == "heartbeat":
                    self.process_heartbeat(request)
            if self.leader != self.id:
                self.check_leader_timeout()
            else:
                self.send_heartbeats()
                # self.send_append_entries() """
            

    def handle_get(self, get_msg):
        key = get_msg['key']

        # if I am the leader, reply to the get
        if self.role == 'leader' and self.leader == self.id:

            get_reply = {"src": self.id,
                        "dst": get_msg['src'],
                        "leader": self.leader,
                        "type": "ok",
                        "MID": get_msg['MID'],
                        "value": ''}

            # ok with value if in
            if key in self.database.keys():
                value = self.database[key]
                get_reply['value'] = value
                self.send(get_reply)
            else:
                get_reply = {"src": self.id,
                            "dst": get_msg['src'],
                            "leader": self.leader,
                            "type": "fail",
                            "MID": get_msg['MID']}
                self.send(get_reply)
        else:
            get_redirect_msg = {"src": self.id,
                                "dst": get_msg['src'],
                                "leader": self.leader,
                                "type": "redirect",
                                "MID": get_msg['MID']}
            self.send(get_redirect_msg)

    def handle_put(self, put_msg):

        # if this socket is the leader
        if self.role == 'leader' and self.leader == self.id:
            self.database[put_msg['key']] = put_msg['value']
            self.log.append({'src': put_msg['src'],
                        'key': put_msg['key'],
                        'value': put_msg['value'],
                        'MID': put_msg['MID'],
                        'term': self.term})

            append_entries_message = {"src": self.id, "dst": 'Null', "leader": self.leader, "type": "AppendEntries RPC",
                                    "MID": put_msg['MID'], "key": put_msg['key'], "value": put_msg['value']}
            i = 0
            while i < 2:
                self.send_to_all(append_entries_message)
                i += 1

            ok_put_message = {"src": self.id, "dst": put_msg['src'], "leader": self.leader, "type": "ok", "MID": put_msg['MID']}
            self.send(ok_put_message)

        else:
            if self.leader == 'FFFF':
                self.start_election()
            else:
                # if this socket is not the leader redirect
                redirect_put_msg = {"src": self.id,
                                "dst": put_msg['src'],
                                "leader": self.leader,
                                "type": "redirect",
                                "MID": put_msg['MID']}
                self.send(redirect_put_msg)
                print(" redirected a put request + current role and leader are " + str(self.leader) + self.state)
            
    

    def start_election(self):
        # increments its current term and transitions to candidate state.
        self.term += 1
        self.role = 'candidate'

        # It then votes for itself and issues RequestVote RPCs
        votedFor = self.id
        self.votes += 1

        request_vote_msg = {'src': self.id,
                            'dst': "NULL",
                            'leader': self.leader,
                            'type': 'RequestVote RPC',
                            'term': self.term,
                            'candidate_id': self.id,
                            }

        print(request_vote_msg)
        # broadcast the request vote rpc to all replicas
        self.send_to_all(request_vote_msg)

    def handle_request_vote(self, request_vote_msg):
        print("Received a request vote from " + request_vote_msg['src'])
        request_vote_reply = {'src': self.id,
                            'dst': request_vote_msg['src'],
                            'leader': self.leader,
                            'type': 'Null',
                            'term': self.term
                            }

        if self.votedFor == '':
            request_vote_reply['type'] = 'VoteTrue'
            self.votedFor = request_vote_msg['src']
            self.send(request_vote_reply)
            print(str(self.id) + " sent a vote to " + str(request_vote_reply['dst']))
        else:
            request_vote_reply['type'] = 'VoteFalse'
            self.send(request_vote_reply)
            print("Already voted for " + str(self.votedFor))

    def handle_vote(self, vote_true_msg):
        self.votes += 1

        print(str(self.id) + " received a vote from " + vote_true_msg['src'])

        # if majority of votes
        if self.votes >= len(replica_ids) / 2:
            self.leader = self.id
            self.role = 'leader'

            # reset global variables
            self.votes = 0
            self.send_append_entries(replica_ids)

    def send_append_entries(self, destination):
        if self.leader == self.id and self.role == 'leader':
            for replica_id in destination:
                append_entries_msg = {
                    'src': self.id,
                    'dst': replica_id,
                    'type': 'AppendEntries RPC',
                    'leader': self.leader,
                    'term': self.term,
                    "key": '', "value": ''
                }
                self.send(append_entries_msg)

                print(str(self.id) + " sent append entry RPC to " + str(replica_id))

    def handle_rejected_vote(self, rejection_msg):
        if self.role == 'candidate' and rejection_msg['term'] >= self.term:
            self.term = rejection_msg['term']
            self.role = 'follower'

            # reset election variable
            self.votes = 0
            self.votedFor = ''
            self.leader = rejection_msg['leader']

    def handle_append_entries(self, append_entries_rpc):
        if append_entries_rpc['key'] == '' or append_entries_rpc['value'] == '':
            # heartbeat
            votedFor = ''
            if self.leader == 'FFFF' or not self.leader == append_entries_rpc['leader']:
                self.leader = append_entries_rpc['leader']
                help(str(self.id) + " set leader to " + str(self.leader))
        else:
            self.database[append_entries_rpc['key']] = append_entries_rpc['value']

    '''
    Sends a message to the client.
    Params:
        message: the message to send
    '''
    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_to_all(self, send_to_all_msg):
        for replica_id in replica_ids:
            send_to_all_msg['dst'] = replica_id
            self.send(send_to_all_msg)
            print(str(self.id) + " sent " + str(send_to_all_msg))
    '''
    Responds to a client request if this replica is the leader.
    Params:
        request: the request from the client
    '''
    def respond_to_client(self, request):
        if self.check_redirect(request):
            self.process_client_request(request)

    '''
    This method checks if the replica is the leader and sends a redirect message if it is not.
    Params:
        request: the request from the client
    Returns:
        True if the replica is the leader, False otherwise
    '''
    def check_redirect(self, request):
        if self.id != self.leader:
            redirect = {"src": self.id, "dst": request['src'], "leader": self.get_leader(), "type": "redirect", "MID": request['MID']}
            self.send(redirect)
            return False
        else:
            return True
        
    '''
    Returns the leader of the replica or "FFFF" if it is unknown.
    '''
    def get_leader(self):
        return self.leader if self.leader else BROADCAST

    '''
    This leader processes the client request and send back a response.
    '''
    def process_client_request(self, request):
        if request["type"] == "get":
            response = self.process_get_request(request)
        elif request["type"] == "put":
            response = self.process_put_request(request)
        elif request['type'] == "":
            response = self.respond_to_raft_election(request)
        self.append_to_log(request)
        self.apply_log_entries()
        self.send(response)


    '''
    Attempts to send back a response with the key and value.
    Params:
        request: the request from the client
    Returns:
        Either an 'ok' message or a 'fail' message
    '''
    def process_get_request(self, request):
        val = ""
        try:
            val = self.database.get(request["key"])           
        except KeyError:
            pass
        return {"src": self.id, "dst": request['src'], "leader": self.get_leader(), "type": "ok", "MID": request['MID'],
                "value": val}

    '''
    Attempts to enter the given key-value pair into the database.
    Params:
        request: the request from the client
    '''
    def process_put_request(self, request):
        try:
            self.database[request["key"]] = request["value"]
        except KeyError:
            pass
        return {"src": self.id, "dst": request['src'], "leader": self.get_leader(), "type": "ok", "MID": request['MID']}
    
    '''
    Processes the heartbeat message received from the leader.
    '''
    def process_heartbeat(self, request):
        self.last_heartbeat = time.time()
        self.leader = request["leader"]
        if self.ongoing_election:
            self.end_election()


    def append_to_log(self, entry):
        self.log.append(entry)
    
    





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()

